name: Database Upgrade (dispatch)

on:
  workflow_dispatch:
    inputs:
      target:
        description: Deployment target; usually PR number, test, or prod
        type: string
        required: true

permissions: {}

env:
  NAME: fom
  COMPONENT: db
  DB_UPGRADE_VERSION: v17

jobs:
  db-major-upgrade:
    runs-on: ubuntu-latest
    permissions:
      packages: write
    env:
      ZONE: ${{ inputs.target }}
        
    steps:
    - name: Checkout
      if: ${{ env.ZONE != 'prod' }}
      uses: actions/checkout@v4

    - name: Build and Push new db version Docker Image (for db upgrade)
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-builder-ghcr@v2.3.0
      with:
        package: ${{ env.COMPONENT }}
        build_context: ./db
        build_file: ./db/Dockerfile-V17
        tag: ${{ env.DB_UPGRADE_VERSION }}-upgrade
        tag_fallback: latest
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: OpenShift Init
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-deployer-openshift@v3.2.0
      with:
        oc_namespace: ${{ vars.OC_NAMESPACE }}
        oc_server: ${{ vars.OC_SERVER }}
        oc_token: ${{ secrets.OC_TOKEN }}
        file: libs/openshift.init.yml
        overwrite: false
        parameters: -p ZONE=${{ env.ZONE }}

    - name: Parameters preparation
      id: prepare
      run: echo "::set-output name=current_date::$(date +'%Y-%m-%d-%H-%M')"

    - name: Scale Down API Component
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Scaling down the API component..."
        oc scale deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} --replicas=0
        echo "Waiting for API pods to terminate..."
        for i in {1..15}; do
          POD_COUNT=$(oc get pods -n ${{ vars.OC_NAMESPACE }} -l deployment=${NAME}-${ZONE}-api -o jsonpath='{.items[*].status.phase}' | wc -w)
          if [ "$POD_COUNT" -eq 0 ]; then
            echo "All API pods have been terminated."
            break
          fi
          echo "API pods are still terminating. Retrying in 5 seconds..."
          sleep 10
        done

        if [ "$POD_COUNT" -ne 0 ]; then
          echo "Error: API pods did not terminate within the timeout period."
          exit 1
        fi

    - name: Perform old Database Backup
      if: ${{ env.ZONE != 'prod' }}
      env:
        BACKUP_FILE_NAME: backup-${{ steps.prepare.outputs.current_date }}.dump
      run: |
        echo "Performing database backup..."
        oc exec deployment/${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} -- \
            bash -c 'pg_dump -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -Fc > "/backups/${{env.BACKUP_FILE_NAME}}"'

    - name: Verify Backup File Exists
      if: ${{ env.ZONE != 'prod' }}
      env:
        BACKUP_FILE_NAME: backup-${{ steps.prepare.outputs.current_date }}.dump
      run: |
        echo "Verifying backup file exists..."
        BACKUP_FILE_PATH="/backups/${{env.BACKUP_FILE_NAME}}"
        oc exec deployment/${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} -- \
          test -f $BACKUP_FILE_PATH
        if [ $? -eq 0 ]; then
          echo "Backup file verified: $BACKUP_FILE_PATH"
        else
          echo "Error: Backup file not found: $BACKUP_FILE_PATH"
          exit 1
        fi

    - name: OpenShift Deploy (db upgrade container)
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-deployer-openshift@v3.2.0
      with:
        file: db/openshift.deploy.dbupgrade.v17.yml
        oc_namespace: ${{ vars.OC_NAMESPACE }}
        oc_server: ${{ vars.OC_SERVER }}
        oc_token: ${{ secrets.OC_TOKEN }}
        overwrite: true
        parameters:
          -p ZONE=${{ env.ZONE }}
        triggers: ('db')

    - name: Verify db upgrade container Deployment Readiness
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Checking if deployment is ready..."
        for i in {1..30}; do
          READY_REPLICAS=$(oc get deployment ${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.status.readyReplicas}' || echo "0")
          if [ "$READY_REPLICAS" == "1" ]; then
            echo "Deployment is ready."
            break
          fi
          echo "Deployment not ready yet. Retrying in 5 seconds..."
          sleep 5
        done

        if [ "$READY_REPLICAS" != "1" ]; then
          echo "Error: Deployment did not become ready within the timeout period."
          exit 1
        fi

    - name: Verify PostGIS Extension Installation at db upgrade container
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Verifying PostGIS extension is installed..."
        POSTGIS_VERSION=$(oc exec deployment/${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -- \
          bash -c 'psql -U $POSTGRES_USER -d $POSTGRES_DB -tAc "SELECT installed_version FROM pg_available_extensions WHERE name = '\''postgis'\'';"')
        if [ -z "$POSTGIS_VERSION" ]; then
          echo "Error: PostGIS extension is not installed."
          exit 1
        else
          echo "PostGIS extension is installed. Version: $POSTGIS_VERSION"
        fi

    - name: Restore from Backup into New Database
      if: ${{ env.ZONE != 'prod' }}
      env:
        BACKUP_FILE_PATH: "/backups/backup-${{ steps.prepare.outputs.current_date }}.dump"
      run: |
        echo "Restoring database from backup..."
        oc exec deployment/${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -- \
          bash -c 'pg_restore --if-exists -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" "${{env.BACKUP_FILE_PATH}}"'
        if [ $? -eq 0 ]; then
          echo "Database restoration completed successfully."
        else
          echo "Error: Database restoration failed."
          exit 1
        fi

    - name: Verify Database Restoration
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Verifying database restoration..."
        RESTORE_CHECK=$(oc exec deployment/${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -- \
          bash -c 'psql -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -tAc "SELECT COUNT(*) FROM information_schema.tables;"')
        if [ "$RESTORE_CHECK" -gt 0 ]; then
          echo "Database restoration verified. Number of tables: $RESTORE_CHECK"
        else
          echo "Error: Database restoration verification failed. No tables found."
          exit 1
        fi

    - name: Point API Component to New Database
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Updating API component to point to the new database..."
        NEW_DB_HOST="${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION}"
        oc set env deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} DB_HOST=$NEW_DB_HOST
        echo "API component updated to use the new database: $NEW_DB_HOST"

    - name: Scale Up API Component
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Scaling up the API component to its original replicas..."
        ORIGINAL_REPLICAS=$(oc get deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.spec.replicas}')
        if [ -z "$ORIGINAL_REPLICAS" ]; then
          echo "Error: Unable to determine the original number of replicas for the API component."
          exit 1
        fi
        oc scale deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} --replicas=$ORIGINAL_REPLICAS
        echo "API component scaled up to $ORIGINAL_REPLICAS replicas."

        echo "Verifying the API component has scaled up..."
        for i in {1..30}; do
          READY_REPLICAS=$(oc get deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.status.readyReplicas}' || echo "0")
          if [ "$READY_REPLICAS" == "$ORIGINAL_REPLICAS" ]; then
          echo "API component has successfully scaled up to $READY_REPLICAS replicas."
          break
          fi
          echo "API component is not fully scaled up yet. Retrying in 5 seconds..."
          sleep 5
        done

        if [ "$READY_REPLICAS" != "$ORIGINAL_REPLICAS" ]; then
          echo "Error: API component did not scale up to the expected number of replicas within the timeout period."
          exit 1
        fi

    - name: Verify API Component is Responding
      # TODO: PROD API_URL will be different.
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Verifying API component is responding..."
        API_URL="https://${NAME}-${ZONE}.apps.silver.devops.gov.bc.ca/api/awsCognitoConfig"
        RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $API_URL)
        if [ "$RESPONSE" -eq 200 ]; then
          echo "API component is responding successfully."
        else
          echo "Error: API component is not responding. HTTP status code: $RESPONSE"
          exit 1
        fi

