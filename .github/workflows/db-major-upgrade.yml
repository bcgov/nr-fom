name: Database Upgrade (dispatch)

on:
  workflow_dispatch:
    inputs:
      target:
        description: Deployment target; usually PR number, test, or prod
        type: string
        required: true

permissions: {}

env:
  NAME: fom
  ZONE: ${{ inputs.target }}
  COMPONENT: db
  DB_UPGRADE_VERSION: v17

jobs:
  db-major-upgrade:
    runs-on: ubuntu-latest
    permissions:
      packages: write

    steps:
    - name: Checkout
      if: ${{ env.ZONE != 'prod' }}
      uses: actions/checkout@v4

    - name: Build and Push new db version Docker Image (for db upgrade)
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-builder-ghcr@v2.3.0
      with:
        package: ${{ env.COMPONENT }}
        build_context: ./db
        build_file: ./db/Dockerfile-V17
        tag: ${{ env.DB_UPGRADE_VERSION }}-upgrade
        tag_fallback: latest
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: OpenShift Init
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-deployer-openshift@v3.2.0
      with:
        oc_namespace: ${{ vars.OC_NAMESPACE }}
        oc_server: ${{ vars.OC_SERVER }}
        oc_token: ${{ secrets.OC_TOKEN }}
        file: libs/openshift.init.yml
        overwrite: false
        parameters: -p ZONE=${{ env.ZONE }}

    - name: Parameters preparation
      id: prepare
      run: echo "::set-output name=current_date::$(date +'%Y-%m-%d-%H-%M')"

    - name: Scale Down API Component
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Scaling down the API component..."
        oc scale deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} --replicas=0
        echo "Waiting for API pods to terminate..."
        for i in {1..15}; do
          POD_COUNT=$(oc get pods -n ${{ vars.OC_NAMESPACE }} -l deployment=${NAME}-${ZONE}-api -o jsonpath='{.items[*].status.phase}' | wc -w)
          if [ "$POD_COUNT" -eq 0 ]; then
            echo "All API pods have been terminated."
            break
          fi
          echo "API pods are still terminating. Retrying in 5 seconds..."
          sleep 10
        done

        if [ "$POD_COUNT" -ne 0 ]; then
          echo "Error: API pods did not terminate within the timeout period."
          exit 1
        fi

    - name: Perform old Database Backup
      if: ${{ env.ZONE != 'prod' }}
      env:
        BACKUP_FILE_NAME: backup-${{ steps.prepare.outputs.current_date }}.dump
      run: |
        echo "Performing database backup..."
        oc exec deployment/${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} -- \
            bash -c 'pg_dump -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -Fc > "/backups/${{env.BACKUP_FILE_NAME}}"'

    - name: Verify Backup File Exists
      if: ${{ env.ZONE != 'prod' }}
      env:
        BACKUP_FILE_NAME: backup-${{ steps.prepare.outputs.current_date }}.dump
      run: |
        echo "Verifying backup file exists..."
        BACKUP_FILE_PATH="/backups/${{env.BACKUP_FILE_NAME}}"
        oc exec deployment/${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} -- \
          test -f $BACKUP_FILE_PATH
        if [ $? -eq 0 ]; then
          echo "Backup file verified: $BACKUP_FILE_PATH"
        else
          echo "Error: Backup file not found: $BACKUP_FILE_PATH"
          exit 1
        fi

    - name: OpenShift Deploy (db upgrade container)
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-deployer-openshift@v3.2.0
      with:
        file: db/openshift.deploy.dbupgrade.v17.yml
        oc_namespace: ${{ vars.OC_NAMESPACE }}
        oc_server: ${{ vars.OC_SERVER }}
        oc_token: ${{ secrets.OC_TOKEN }}
        overwrite: true
        parameters:
          -p ZONE=${{ env.ZONE }}
        triggers: ('db')

    - name: Verify db upgrade container Deployment Readiness
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Checking if deployment is ready..."
        for i in {1..30}; do
          READY_REPLICAS=$(oc get deployment ${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.status.readyReplicas}' || echo "0")
          if [ "$READY_REPLICAS" == "1" ]; then
            echo "Deployment is ready."
            break
          fi
          echo "Deployment not ready yet. Retrying in 5 seconds..."
          sleep 5
        done

        if [ "$READY_REPLICAS" != "1" ]; then
          echo "Error: Deployment did not become ready within the timeout period."
          exit 1
        fi

    - name: Verify PostGIS Extension Installation at db upgrade container
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Verifying PostGIS extension is installed..."
        POSTGIS_VERSION=$(oc exec deployment/${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -- \
          bash -c 'psql -U $POSTGRES_USER -d $POSTGRES_DB -tAc "SELECT installed_version FROM pg_available_extensions WHERE name = '\''postgis'\'';"')
        if [ -z "$POSTGIS_VERSION" ]; then
          echo "Error: PostGIS extension is not installed."
          exit 1
        else
          echo "PostGIS extension is installed. Version: $POSTGIS_VERSION"
        fi

    - name: Restore from Backup into New Database
      if: ${{ env.ZONE != 'prod' }}
      env:
        BACKUP_FILE_PATH: "/backups/backup-${{ steps.prepare.outputs.current_date }}.dump"
      run: |
        echo "Restoring database from backup..."
        oc exec deployment/${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -- \
          bash -c 'pg_restore --if-exists --clean -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" "${{env.BACKUP_FILE_PATH}}"'
        if [ $? -eq 0 ]; then
          echo "Database restoration completed successfully."
        else
          echo "Error: Database restoration failed."
          exit 1
        fi

    - name: Verify Database Restoration
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Verifying database restoration..."
        RESTORE_CHECK=$(oc exec deployment/${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -- \
          bash -c 'psql -U "${POSTGRES_USER}" -d "${POSTGRES_DB}" -tAc "SELECT COUNT(*) FROM information_schema.tables;"')
        if [ "$RESTORE_CHECK" -gt 0 ]; then
          echo "Database restoration verified. Number of tables: $RESTORE_CHECK"
        else
          echo "Error: Database restoration verification failed. No tables found."
          exit 1
        fi

    - name: Scale Down Old Database Component
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Scaling down the old database component..."
        oc scale deployment/${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} --replicas=0
        echo "Waiting for old database pods to terminate..."
        for i in {1..15}; do
          POD_COUNT=$(oc get pods -n ${{ vars.OC_NAMESPACE }} -l deployment=${NAME}-${ZONE}-${COMPONENT} -o jsonpath='{.items[*].status.phase}' | wc -w)
          if [ "$POD_COUNT" -eq 0 ]; then
          echo "All old database pods have been terminated."
          break
          fi
          echo "Old database pods are still terminating. Retrying in 10 seconds..."
          sleep 10
        done

        if [ "$POD_COUNT" -ne 0 ]; then
          echo "Error: Old database pods did not terminate within the timeout period."
          exit 1
        fi

    - name: Point API Component to New Database
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Updating API component to point to the new database..."
        NEW_DB_HOST="${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION}"
        oc set env deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} DB_HOST=$NEW_DB_HOST
        echo "API component updated to use the new database: $NEW_DB_HOST"

    - name: Scale Up API Component
      if: ${{ env.ZONE != 'prod' }}
      env:
        REPLICA_COUNT: 3
      run: |
        echo "Scaling up the API component to ${{env.REPLICA_COUNT}} replicas..."
        oc scale deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} --replicas=${{env.REPLICA_COUNT}}

        echo "Verifying the API component has scaled up..."
        for i in {1..50}; do
          READY_REPLICAS=$(oc get deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.status.readyReplicas}' || echo "0")
          if [ "$READY_REPLICAS" == "${{env.REPLICA_COUNT}}" ]; then
          echo "API component has successfully scaled up to $READY_REPLICAS replicas."
          break
          fi
          echo "API component is not fully scaled up yet. Retrying in 5 seconds..."
          sleep 5
        done

        if [ "$READY_REPLICAS" != "${{env.REPLICA_COUNT}}" ]; then
          echo "Error: API component did not scale up to the expected number of replicas within the timeout period."
          exit 1
        fi

    - name: Verify API Component is Responding
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Fetching API route from OpenShift..."
        API_ROUTE=$(oc get route ${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.spec.host}')
        if [ -z "$API_ROUTE" ]; then
          echo "Error: Unable to fetch API route."
          exit 1
        fi

        sleep 10
        API_URL="https://${API_ROUTE}/api/district"
        echo "Verifying API component is responding with http request: ${API_URL}..."
        RESPONSE=$(curl -v /dev/null -w "%{http_code}" $API_URL)
        if [ "$RESPONSE" -eq 200 ]; then
          echo "API component is responding successfully."
        else
          echo "Error: API component is not responding. HTTP status code: $RESPONSE"
          exit 1
        fi

    - name: Update CronJobs to Point to New Database
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Updating CronJobs to point to the new database..."
        NEW_DB_HOST="${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION}"

        # Update work-flow-state-change-batch CronJob
        echo "Updating CronJob: work-flow-state-change-batch..."
        oc set env cronjob/${NAME}-${ZONE}-work-flow-state-change-batch -n ${{ vars.OC_NAMESPACE }} DB_HOST=$NEW_DB_HOST
        echo "CronJob work-flow-state-change-batch updated to use the new database: $NEW_DB_HOST"

        # Update fc-client-data-refresh-batch CronJob
        echo "Updating CronJob: fc-client-data-refresh-batch..."
        oc set env cronjob/${NAME}-${ZONE}-fc-client-data-refresh-batch -n ${{ vars.OC_NAMESPACE }} DB_HOST=$NEW_DB_HOST
        echo "CronJob fc-client-data-refresh-batch updated to use the new database: $NEW_DB_HOST"


## Rollback API component pointing to old database if needed
  rollback:
    runs-on: ubuntu-latest
    needs: db-major-upgrade
    if: failure()  # This ensures the rollback job runs only if the db-major-upgrade job fails.
    steps:
    - name: Scale API Comoponent Down if needed
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Scaling down the API component if needed..."
        oc scale deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} --replicas=0
        echo "Waiting for API pods to terminate..."
        for i in {1..20}; do
          POD_COUNT=$(oc get pods -n ${{ vars.OC_NAMESPACE }} -l deployment=${NAME}-${ZONE}-api -o jsonpath='{.items[*].status.phase}' | wc -w)
          if [ "$POD_COUNT" -eq 0 ]; then
            echo "All API pods have been terminated."
            break
          fi
          echo "API pods are still terminating. Retrying in 10 seconds..."
          sleep 10
        done

        if [ "$POD_COUNT" -ne 0 ]; then
          echo "Error: API pods did not terminate within the timeout period."
          exit 1
        fi

    - name: Scale Up Old Database Component
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Scaling up the old database component..."
        oc scale deployment/${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} --replicas=1
        echo "Waiting for old database pods to be ready..."
        for i in {1..30}; do
          READY_REPLICAS=$(oc get deployment ${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.status.readyReplicas}' || echo "0")
          if [ "$READY_REPLICAS" == "1" ]; then
            echo "Old database component is ready."
            break
          fi
          echo "Old database component not ready yet. Retrying in 5 seconds..."
          sleep 5
        done
        if [ "$READY_REPLICAS" != "1" ]; then
          echo "Error: Old database component did not become ready within the timeout period."
          exit 1
        fi

    - name: Scale Down New Database Component
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Scaling down the new database component..."
        oc scale deployment/${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} --replicas=0

    - name: Rollback API Component to Old Database
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Rolling back API component to point to the old database..."
        OLD_DB_HOST="${NAME}-${ZONE}-${COMPONENT}"
        oc set env deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} DB_HOST=$OLD_DB_HOST
        echo "API component rolled back to use the old database: $OLD_DB_HOST"

    - name: Scale Up API Component
      if: ${{ env.ZONE != 'prod' }}
      env:
        REPLICA_COUNT: 3
      run: |
        echo "Scaling up the API component to ${{env.REPLICA_COUNT}} replicas..."
        oc scale deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} --replicas=${{env.REPLICA_COUNT}}

        echo "Verifying the API component has scaled up..."
        for i in {1..50}; do
          READY_REPLICAS=$(oc get deployment/${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.status.readyReplicas}' || echo "0")
          if [ "$READY_REPLICAS" == "${{env.REPLICA_COUNT}}" ]; then
            echo "API component has successfully scaled up to $READY_REPLICAS replicas."
            break
          fi
          echo "API component is not fully scaled up yet. Retrying in 5 seconds..."
          sleep 5
        done

        if [ "$READY_REPLICAS" != "${{env.REPLICA_COUNT}}" ]; then
          echo "Error: API component did not scale up to the expected number of replicas within the timeout period."
          exit 1
        fi

    - name: Verify API Component is Responding
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Fetching API route from OpenShift..."
        API_ROUTE=$(oc get route ${NAME}-${ZONE}-api -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.spec.host}')
        if [ -z "$API_ROUTE" ]; then
          echo "Error: Unable to fetch API route."
          exit 1
        fi

        sleep 10
        API_URL="https://${API_ROUTE}/api/district"
        echo "Verifying API component is responding with http request: ${API_URL}..."
        RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" $API_URL)
        if [ "$RESPONSE" -eq 200 ]; then
          echo "API component is responding successfully."
        else
          echo "Error: API component is not responding. HTTP status code: $RESPONSE"
          exit 1
        fi

    - name: Update CronJobs to Point to Old Database 
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Updating CronJobs to point to the old database..."
        OLD_DB_HOST="${NAME}-${ZONE}-${COMPONENT}"

        # Update work-flow-state-change-batch CronJob
        echo "Updating CronJob: work-flow-state-change-batch..."
        oc set env cronjob/${NAME}-${ZONE}-work-flow-state-change-batch -n ${{ vars.OC_NAMESPACE }} DB_HOST=$OLD_DB_HOST
        echo "CronJob work-flow-state-change-batch updated to use the old database: $OLD_DB_HOST"

        # Update fc-client-data-refresh-batch CronJob
        echo "Updating CronJob: fc-client-data-refresh-batch..."
        oc set env cronjob/${NAME}-${ZONE}-fc-client-data-refresh-batch -n ${{ vars.OC_NAMESPACE }} DB_HOST=$OLD_DB_HOST
        echo "CronJob fc-client-data-refresh-batch updated to use the old database: $OLD_DB_HOST"