name: Database Upgrade (dispatch)

on:
  workflow_dispatch:
    inputs:
      target:
        description: Deployment target; usually PR number, test, or prod
        type: string
        required: true

permissions: {}

env:
  NAME: fom
  COMPONENT: db
  DB_UPGRADE_VERSION: v17

jobs:
  db-major-upgrade:
    runs-on: ubuntu-latest
    permissions:
      packages: write
    env:
      ZONE: ${{ inputs.target }}

    steps:
    - name: Checkout
      if: ${{ env.ZONE != 'prod' }}
      uses: actions/checkout@v4

    - name: Build and Push Docker Image (for db upgrade)
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-builder-ghcr@v2.3.0
      with:
        package: ${{ env.COMPONENT }}
        build_context: ./db
        build_file: ./db/Dockerfile-V17
        tag: ${{ env.DB_UPGRADE_VERSION }}-upgrade
        tag_fallback: latest
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: OpenShift Init
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-deployer-openshift@v3.2.0
      with:
        oc_namespace: ${{ vars.OC_NAMESPACE }}
        oc_server: ${{ vars.OC_SERVER }}
        oc_token: ${{ secrets.OC_TOKEN }}
        file: libs/openshift.init.yml
        overwrite: false
        parameters: -p ZONE=${{ env.ZONE }}

    - name: Perform old Database Backup
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Performing database backup..."
        BACKUP_FILE_NAME="backup-$(date +'%Y-%m-%d-%H-%M').sql"
        oc exec deployment/${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} -- \
          pg_dump -U $POSTGRES_USER -d $POSTGRES_DB > /backups/$BACKUP_FILE_NAME
        echo "Backup file created: $BACKUP_FILE_NAME"

    - name: Verify Backup File Exists
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Verifying backup file exists..."
        BACKUP_FILE_NAME="backup-$(date +'%Y-%m-%d-%H-%M').sql"
        BACKUP_FILE_PATH="/backups/$BACKUP_FILE_NAME"
        oc exec deployment/${NAME}-${ZONE}-${COMPONENT} -n ${{ vars.OC_NAMESPACE }} -- \
          test -f $BACKUP_FILE_PATH
        if [ $? -eq 0 ]; then
          echo "Backup file verified: $BACKUP_FILE_PATH"
        else
          echo "Error: Backup file not found: $BACKUP_FILE_PATH"
          exit 1
        fi

    - name: OpenShift Deploy (db upgrade container)
      if: ${{ env.ZONE != 'prod' }}
      uses: bcgov/action-deployer-openshift@v3.2.0
      with:
        file: db/openshift.deploy.dbupgrade.v17.yml
        oc_namespace: ${{ vars.OC_NAMESPACE }}
        oc_server: ${{ vars.OC_SERVER }}
        oc_token: ${{ secrets.OC_TOKEN }}
        overwrite: true
        parameters:
          -p ZONE=${{ env.ZONE }}
        triggers: ('db')

    - name: Verify upgrade db Deployment Readiness
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Checking if deployment is ready..."
        for i in {1..30}; do
          READY_REPLICAS=$(oc get deployment ${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -o jsonpath='{.status.readyReplicas}' || echo "0")
          if [ "$READY_REPLICAS" == "1" ]; then
            echo "Deployment is ready."
            break
          fi
          echo "Deployment not ready yet. Retrying in 5 seconds..."
          sleep 5
        done

        if [ "$READY_REPLICAS" != "1" ]; then
          echo "Error: Deployment did not become ready within the timeout period."
          exit 1
        fi

    - name: Verify PostGIS Extension Installation
      if: ${{ env.ZONE != 'prod' }}
      run: |
        echo "Verifying PostGIS extension is installed..."
        POSTGIS_VERSION=$(oc exec deployment/${NAME}-${ZONE}-${COMPONENT}-${DB_UPGRADE_VERSION} -n ${{ vars.OC_NAMESPACE }} -- \
          psql -U $POSTGRES_USER -d $POSTGRES_DB -tAc "SELECT installed_version FROM pg_available_extensions WHERE name = 'postgis';")
        if [ -z "$POSTGIS_VERSION" ]; then
          echo "Error: PostGIS extension is not installed."
          exit 1
        else
          echo "PostGIS extension is installed. Version: $POSTGIS_VERSION"
        fi

